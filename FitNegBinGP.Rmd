---
title: "Negbin GP Regression"
output: html_notebook
---

```{r}
library(rstan)
library(bayesplot)
library(shinystan)
library(dplyr)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)

library(colormap)

c_light <- c("#DCBCBC")
c_light_highlight <- c("#C79999")
c_mid <- c("#B97C7C")
c_mid_highlight <- c("#A25050")
c_dark <- c("#8F2727")
c_dark_highlight <- c("#7C0000")

nom_colors <- c("#DCBCBC", "#C79999", "#B97C7C", "#A25050", "#8F2727", "#7C0000")

c_light_teal <- c("#6B8E8E")
c_mid_teal <- c("#487575")
c_dark_teal <- c("#1D4F4F")
```

```{r}
data = read.csv('Outputs/SimulatedNegBinData.csv')
```

```{r}
ggplot(data = data, aes(x = x_obs, y = y_obs)) + geom_jitter(alpha = 0.2)
```

```{stan output.var=FitNegbinGP}
data {
  int<lower=1> T;
  int<lower=1> N;
  matrix[N, T] X;
  int y_obs[N];
  real x[T];
}

transformed data {
}

parameters {

  // mean and dispersion we are trying to estimate
  // non-rescaled
  vector[T] mu_tilde;
  vector[T] phi_tilde;
  
  // mean gaussian process pars
  real<lower=0> rho_mu;
  real<lower=0> alpha_mu;
  
  // dispersion parameter gaussian process
  real<lower=0> rho_phi;
  real<lower=0> alpha_phi;
}

transformed parameters {

  // Covariance for the mean GP
  matrix[T, T] cov_mu =   cov_exp_quad(x, alpha_mu, rho_mu) + diag_matrix(rep_vector(1e-10, T));
  matrix[T, T] L_cov_mu = cholesky_decompose(cov_mu);
  
  // Covariance for the dispersion GP
  matrix[T, T] cov_phi =   cov_exp_quad(x, alpha_phi, rho_phi) + diag_matrix(rep_vector(1e-10, T));
  matrix[T, T] L_cov_phi = cholesky_decompose(cov_phi);
  
  // exponentiated mean gaussian process
  vector[T] mu = exp(rep_vector(0, T) + L_cov_mu * mu_tilde);
  
  // exponentiated dispersion gaussian process
  vector[T] phi = exp(rep_vector(0, T) + L_cov_phi * phi_tilde);
}

model {
  // mu prior
  alpha_mu ~ exponential(3);
  rho_mu ~ exponential(3);
  
  // phi prior
  alpha_phi ~ exponential(3);
  rho_phi ~ exponential(3);
  
  // non-rescaled GP's
  mu_tilde ~ normal(0, 1);
  phi_tilde ~ normal(0, 1);
  
  // design matrix multiplied by mean and dispersion parameters
  y_obs ~ neg_binomial_2(X * mu, X * phi);
}

generated quantities {
  vector[T] mu_predict = mu;
  vector[T] phi_predict = phi;
  int y_predict[T] = neg_binomial_rng(mu, phi);
}
```

```{r}
x_obs = data$x_obs
X = model.matrix( ~ as.factor(x_obs) - 1)
```


```{r}
data_in = list(
  T = 100,
  N = dim(data)[1],
  X = X,
  y_obs = data$y_obs,
  x = 1:100
)
```



```{r}
simu = rstan::sampling(
  object = FitNegbinGP,
  data = data_in,
  seed = 1,
  control = list(adapt_delta = 0.99))
```

```{r}
launch_shinystan(simu)
```


```{r}
samples = rstan::extract(simu)
```

```{r}
y_obs = samples$y[5,]
qplot(1:100, y_obs, alpha = I(0.2))
```

```{r}
samples = rstan::extract(simu)
```






```{r}
probs = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:100,
               function(n) quantile((samples$y_predict[,n]), probs=probs))

x_vals = data_in$x

plot(1, type="n", main='credible intervals',
     xlab="x", ylab="f", xlim=c(min(x_vals), max(x_vals)), ylim = c(0, 70))


polygon(c(x_vals, rev(x_vals)), c(cred[1,], rev(cred[9,])),
        col = c_light, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[2,], rev(cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[3,], rev(cred[7,])),
        col = c_mid, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[4,], rev(cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x_vals, cred[5,], col=c_dark, lwd=2)
```


```{r}

probs = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:100,
               function(n) quantile(exp(samples$mu_tilde[,n]), probs=probs))

x_vals = data_in$x

plot(1, type="n", main='credible intervals',
     xlab="x", ylab="f", xlim=c(min(x_vals), max(x_vals)), ylim = c(0, 5))


polygon(c(x_vals, rev(x_vals)), c(cred[1,], rev(cred[9,])),
        col = c_light, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[2,], rev(cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[3,], rev(cred[7,])),
        col = c_mid, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[4,], rev(cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x_vals, cred[5,], col=c_dark, lwd=2)
```


```{r}

probs = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:100,
               function(n) quantile(exp(samples$phi_tilde[,n]), probs=probs))

x_vals = data_in$x

plot(1, type="n", main='credible intervals',
     xlab="x", ylab="f", xlim=c(min(x_vals), max(x_vals)), ylim = c(0, 5))


polygon(c(x_vals, rev(x_vals)), c(cred[1,], rev(cred[9,])),
        col = c_light, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[2,], rev(cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[3,], rev(cred[7,])),
        col = c_mid, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[4,], rev(cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x_vals, cred[5,], col=c_dark, lwd=2)
```
```

