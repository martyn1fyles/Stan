---
title: "R Notebook"
output: html_notebook
---

```{r}
library(rstan)
library(bayesplot)
library(shinystan)
library(tidybayes)
library(dplyr)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```

## Simulating some data

We begin by specifying a model in Stan where we can simulate some data generated by Poisson process with mean modelled by a Gaussian process.

$f \sim GP(0, k_{eq})$
$y_n \sim Poisson(\mu + \exp(f(x_n)))$

```{stan output.var=negbin_gp_mean}
data {
  int<lower=1> N;
  real x[N];

  real<lower=0> rho;
  real<lower=0> alpha;
  real<lower=0> mu;
}

transformed data {
  matrix[N, N] cov =   cov_exp_quad(x, alpha, rho)
                     + diag_matrix(rep_vector(1e-10, N));
  matrix[N, N] L_cov = cholesky_decompose(cov);
}

parameters {}
model {}

generated quantities {
  // 
  vector[N] f = multi_normal_cholesky_rng(rep_vector(mu, N), L_cov);
  int y[N] = poisson_log_rng(f); // uses the exponential log link function
}
```


```{r}
data_true = list(
  N = 100,
  x = seq(1, 100),
  rho = 3,
  alpha = 1,
  mu = 0.25
)
```

We call stan with the fixed param algorithm (as there is nothing to fit). We are passing all the true parameters to stan, and asking it to generated samples.

```{r}
simulated_data = rstan::sampling(
  negbin_gp_mean, 
  data = data_true, 
  algorithm = 'Fixed_param',
  chains=1,
  warmup=0,
  iter=4000,
  seed=1
)
```


```{r}
simulated_data_extracted = rstan::extract(simulated_data)
```


```{r}
qplot(seq(1, 100), simulated_data_extracted$y[2,])
```

```{r}
qplot(seq(1, 100), exp(simulated_data_extracted$f[2,]), type = 'l')
```

```{r}
y_obs = simulated_data_extracted$y[2,]
x_obs = seq(1, 100)
N_obs = 100
mu_obs = exp(simulated_data_extracted$f[2,])
```

## Lets try fitting a model to this lovely data we generated

```{stan output.var=fit_gp_mean_poisson}
data {
  int<lower=1> N;
  real x[N];
  int y_obs[N];
}

parameters {
  vector[N] f_tilde;
  real mu;
  real<lower=0> rho;
  real<lower=0> alpha;
}

transformed parameters {
  matrix[N, N] cov =   cov_exp_quad(x, alpha, rho)
                     + diag_matrix(rep_vector(1e-10, N));
  matrix[N, N] L_cov = cholesky_decompose(cov);
}

model {
  f_tilde ~ normal(0, 1);
  
  y_obs ~ poisson_log(rep_vector(mu, N) + L_cov * f_tilde);
}

generated quantities {
  vector[N] f_predict = rep_vector(mu, N) + L_cov * f_tilde;
  int y_predict[N] = poisson_log_rng(f_predict);
}
```

```{r}
data_in = list(
  N = 100,
  x = x_obs,
  y_obs = y_obs
)
```


```{r}
fitted_data = rstan::sampling(
  fit_gp_mean_poisson, 
  data = data_in
)
```

```{r}
launch_shinystan(fitted_data)
```


```{r}
qplot(seq(1, 100), fit$f_predict[4,])
```


```{r}
est_mu_mean = colMeans(fit$f_predict)
```

```{r}
qplot(seq(1, 100), exp(est_mu_mean))
```


```{r}
qplot(seq(1, 100), mu_obs)
```



```{r}
samples = rstan::extract(fitted_data)
probs = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:100,
               function(n) quantile(samples$y_predict[,n], probs=probs))
```

```{r}
x_vals = data_in$x

plot(1, type="n", main='credible intervals',
     xlab="x", ylab="f", xlim=c(min(x_vals), max(x_vals)), ylim = c(0, 4))


polygon(c(x_vals, rev(x_vals)), c(cred[1,], rev(cred[9,])),
        col = c_light, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[2,], rev(cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[3,], rev(cred[7,])),
        col = c_mid, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[4,], rev(cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x_vals, cred[5,], col=c_dark, lwd=2)

#points(x_vals, data_in$y_obs)
```

```{r}
samples = rstan::extract(fitted_data)
probs = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:100,
               function(n) quantile((samples$f_predict[,n]), probs=probs))
```

```{r}
x_vals = data_in$x

plot(1, type="n", main='credible intervals',
     xlab="x", ylab="f", xlim=c(min(x_vals), max(x_vals)), ylim = c(0, 3))


polygon(c(x_vals, rev(x_vals)), c(cred[1,], rev(cred[9,])),
        col = c_light, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[2,], rev(cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[3,], rev(cred[7,])),
        col = c_mid, border = NA)
polygon(c(x_vals, rev(x_vals)), c(cred[4,], rev(cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x_vals, cred[5,], col=c_dark, lwd=2)

points(x_vals, simulated_data_extracted$f[2,])
```





